// Contract with an Integer Overflow vulnerability
outputStruct main(inputStruct in) {
    outputStruct out;

    // Assumes state is stored as:
    // [user_address_1] => balance
    // [user_address_2] => balance
    // ...

    long long sender_balance = load_long_long_state(in.sender);

    // Function to transfer tokens
    if (in.functionName == "transfer") {
        // expect in.params to have [recipient_address, amount]
        char* recipient_address = get_string_from_params(in.params, 0);
        long long transfer_amount = get_long_long_from_params(in.params, 1);

        // VULNERABILITY: No check for overflow.
        // If a user transfers a large amount to someone who already has a large balance,
        // the recipient's balance can wrap around to a small number.
        // e.g., (MAX_LONG_LONG - 10) + 20 = small number
        if (sender_balance >= transfer_amount) {
            long long recipient_balance = load_long_long_state(recipient_address);

            save_long_long_state(in.sender, sender_balance - transfer_amount);
            save_long_long_state(recipient_address, recipient_balance + transfer_amount); // Overflow can happen here

            out.success = true;
        } else {
            out.success = false;
        }
    }

    // Function to get balance
    if (in.functionName == "getBalance") {
        set_long_long_return(sender_balance);
        out.success = true;
    }

    return out;
}
